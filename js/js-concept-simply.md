# Javascript 개념 (Javascript inside reviews)


1. 함수도 객체  Function() 기본 내장함수로 생성됨.(객체니까 [[Prototype]](\__proto\__) 프로퍼티 존재)
2. 모든 함수(객체)는 따라서 Function.prototype 객체를 부모로 가짐.
3. 모든 함수는 prototype 프로퍼티를 가지고있음. 이 함수를 생성자로 쓰면, 이 생성자함수로 생성된 객체는 \__proto\__ 프로퍼티로 생성자함수.prototype 객체를 가리킴.
  - 모든 함수는 prototype, 모든 객체는 \__proto\__ 있음
4. 객체의 [[Prototype]](\__proto\__) 프로퍼티는 생성자함수(객체)의 prototype 프로퍼티를 기반으로 생성됨.(같은 프로타입객체 가리킴)
5. 모든 함수객체는 부모로 Function.prototype을 가리키므로, Function.prototype의 프로퍼티(apply()) 사용가능
  - Array.prototype.slice.**apply(this, args)**;
6. 함수의 prototype 프로퍼티 : 이 함수가 생성자로 사용될때, 이 함수를 통해 생성된 객체의 부모(프로터 타입객체)
7. 전역변수는 전역객체의 프로퍼티([[Scope]]체인중 최초 전역 변수객체 안에 있는 프로퍼티 이므로)
8. arguments객체 : 함수 실행될되 내부적으로 함수에 전달됨(파라미터들을 가리킴)
9. this 바인딩 : runtime시 binding이 결정됨
  - 메서드호출 - 해당객체로 바인딩
  - 함수호출   - 전역객체로 바인딩
  - 생성자 호출 - 생성된 객체로 바인딩
10. 실행컨텍스트(Stack Frame과 비슷한개념), 활성객체(변수객체) (실행컨텍스트에는 변수객체 1개있다.)
11. 변수객체 프로퍼티 구성 : 파라미터, 내부생성함수, 로컬변수, [[Scope]]체인등.
12. 변수객체에 함수가있다는것은, 해당 실행컨텍스트에서 **생성** 된 함수라는것.
13. 함수는 자신이 생성된 실행컨텍스트 변수객체의 [[Scope]]를 자신의 [[Scope]]로 참조하고있다.
14. 변수 참조는 [[Scope]] 체인에서 찾는다.
15. [[Scope]]체인 - 변수객체의 링크드 리스트.
16. 전역 실행컨텍스트의 변수객체는 전역객체로 사용된다.
  - 전역변수 == 전역객체의 프로퍼티 인 이유이다.
17. 실행컨텍스트가 실행될때 스코프 정보가 생성된다(스코프체인)
  - 함수 실행으로 실행컨텍스트가 생성이된다면, 그 함수의 [[Scope]]체인을 기반으로 새로운 [[Scope]]체인 생성.
  - 스코프체인 = 현재 실행 컨텍스트의 변수객체 + 상위 컨텍스트의 스코프체인
18. 함수객체의 [[Scope]]는  현재 실행되고있는 실행컨텍스트의 변수객체 [[Scope]]를 그대로 가짐 (자신이 **생성** 된 실행컨텍스트 스코프체인참조)
19. 함수객체가 실행이되면 새로운 실행 컨텍스트, 새로운 변수객체가 생성되고, 변수객체의 [[Scope]]는 그 함수의 [[Scope]]앞에 자신(변수객체)을 추가해서 새로운 [[Scope]]체인 프로퍼티를 가진다.

20. 클로져 : 이미 생명주기가 끝난 함수의 변수(자유변수)를 참조하는 함수.
  - 가능이유 : 이전 함수의 실행컨텍스트는 종료되었지만, 이전 변수객체는 [[Scope]]를 통해 계속 참조될수있으므로.
