## 컴퓨터 시스템의 동작원리
#### 컴퓨터 시스템의 구조
컴퓨터 시스템 구조는<br/>
내부장치 : CPU, 메모리<br/>
외부장치 : 디스크, 키보드, 모니터, 네트워크 장치 로 구성된다.<br/><br/>
**p.68 그림삽입**
- CPU 구성
   - mode bit : CPU점유하는게 OS, 사용자P 구분값
   - register : CPU의 저장소
   - interrupt line : 인터럽트 발생 확인용. instruction 수행후 항상 interrupt line 체크한다.
- timer : 특정P의 CPU 무한 점유 방지를 위한 하드웨어
   - OS가 사용자P에 CPU를 넘길때 timer에 한계시간을 세팅한다.
   - 한계시간이 초과하면, timer는 timer-interrupt 발생시킨다.
   - CPU 를 다시 OS가 점유하고, 다른 사용자P에 CPU 넘길수 있다.<br/>
   \* OS는 CPU제어권을 사용자P로 줄수는 있지만, 직접 뺏을수는 없다.
- local 버퍼 : 입출력장치로부터 출입하는  데이터 임시저장
- device controller : 입출력 장치의 미니 CPU, 디스크에서 버퍼로 데이터 읽기 완료했다면 하드웨어 인터럽트 발생시킨다.<br/>
  (CPU는 인터럽트처리루틴을 수행해서 로컬버퍼 -> 메모리로 데이터 복사한다)  

   
<br/>

####CPU 연산과 I/O연산
컴퓨터가 연산을 한다는것은 CPU가 무언가 일을 한다는것. (CPU는 메모리하고만 일한다)<br/>
입출력장치 I/O, CPU는 동시 수행이 가능하다.
1. 프로그램A가 디스크로부터 데이터 읽은 작업이 수행된다면
   - 인터럽트가 발생, 인터럽트처리루틴이 실행되고, 프로그램A는 봉쇄상태
   - OS가 CPU제어권 가지기 시작 
2. 인터럽트 처리루틴에 의해 CPU는 그 실제 일을 device controller에게 전담시키고
3. 실제 device controller가 디스크 -> 버퍼로 데이터 옮기고
4. 그 도중 OS는 프로그램B에 CPU할당해 다른 프로그램를 수행할 수 있다.
   - CPU제어권은 다시 사용자 프로그램으로

```
os의 device처리는 device driver설치후 접근가능, CPU는 정확히 OS내 device drive의 instruction을 수행하는것이다
```
<br/>


####인터럽트의 일반적 기능
운영체제 커널에는 인터럽트가 들어왔을때 해야 할 일이 미리 다 프로그래밍되어 크 코드가 보관되어있다. : **인터럽트 처리루틴**
<br/>
인터럽트 : CPU 옆에 interrupt line에 신호를 보내 알려준다

|소프트웨어 인터럽트|하드웨어 인터럽트|
|------|---|
| - system call : OS내부정의된 코드 실행하고싶을때 요청하는 방법 <br/> - exception : 0으로 나눌때 상황|컨트롤러, timer가 interrupt라인세팅|

<br/>

####인터럽트 핸들링
인터럽트가 발생한 경우 처리해야할 절차
1. 기존 프로세스의 실행데이터(메모리주소, 레지스터값 : PCB구성데이터) 등 저장
2. 인터럽트 처리루틴 실행
3. 1의값 복원해서 다시 실행
<br/>
* PCB(Process Control Block) : 각각 프로그램마다 존재, 프로그램을 관리하기위한 자료구조

<br/>

####DMA(Direct Memory Access)
원칙적으로 메모리는 **CPU에 의해서만 접근 가능**한 장치이다
<br/>
(device controller는 로컬버퍼만 접근, CPU는 메모리접근, 로컬버퍼접근 가능. 로컬버퍼 <-> 메모리 복사 가능)

<br/>
p.80 그림3-4
<br/>

- CPU는 오직 instruction만 수행할 뿐이다.
- 인터럽트가 발생하면, CPU는 메로리와 로커버퍼사이 데이터를 옮기는 역할을 한다.
- 하지만 인터럽트가 빈번하면, CPU효율 저하된다
- **DMA는 CPU가 입출력장치들의 메모리 접근요청에 의해 자주 인터럽트 당하는것을 막아준다**

  DMA의 역할 흐름
  ```
   읽기할때 로컬버퍼 -> 메모리로 데이터 가져오는 작업을 DMA가 한다.
   이 작업을 byte단위가 아니라 큰 block단위로 하고
   1 block만큼 데이터 이동되면 그때 CPU에 interrupt건다
  ```

<br/>

####하드웨어 보안
OS는 다중프로그램 환경에서 실행된다. 프로그램간 충돌, 문제를 방지하기위해 아트웨어 보안기법 필요하다
<br/>
CPU내부에 **모드 비트(mode bit)**를 두어 하드웨어적인 보안 지원을 한다.

|모드비트 0|모드비트 1|
|------|---|
| OS 커널모드 | OS 사용자모드 |
| interrupt, exception시 하드웨어가 0 세팅 | OS가 1로 세팅하고 사용자P에 CPU넘김 |
| device controller, 메모리 접근가능| 한정된 instruction 수행|
| OS가 CPU제어권가짐| 사용자P가 CPU점유|

<br/>

####메모리 보안
프로그램이 다른프로그램,OS의 인터럽트 처리루틴 침범하는것을 방지하기 위해 필요하다.
<br/>
- 기준레지스터(base register), 한계레지스터(limit register)를 통해 메모리 보호한다
<br/>
(하나의 프로그램이 <u>메모리에 연속적으로 위치</u>할때만 가능한기법, 프로그램이 여러 메모리영역에 나누어 위치되는 paging 기법에는 다른방법사용한다)
- 기준레지스터 : 프로그램에 접근할수있는 가장작은주소
- 한계레지스터 : 프로그램의 길이
- CPU가 접근하는 논리적주소가 기준레지스터 ~ 기준레지스터+한계레지스터 범위 밖이면 소프트웨어 인터럽트 발생한다.(프로그램강제종료)

####CPU 보호
한 프로그램에 의핸 독점되는것을 막기위해 **timer**을 사용한다.
<br/>
한계시간(timer 세팅시간)초과하면 timer interrupt에 의해 인터럽트 처리루틴이 다른 사용P에 CPU 이양한다.