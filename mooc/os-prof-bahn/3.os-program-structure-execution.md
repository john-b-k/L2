##프로그램의 구조와 실행
####프로그램의 구조와 인터럽트
프로그램의 함수들로 구성된다. 프로그램이 실행되려면 메모리에 올라가야한다.
<br/>
이때 프로그램의 주소영역은
- 코드 : 프로그램의 함수들의 코드가 CPU에서 수행될수있게 기계어 명령(machine instruction)형태로 저장되는 곳
- 데이터 : 전역변수(global variable)등 프로그램이 사용하는 데이터 저장하는 곳
- 스택 : 호출된 함수가 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 곳
<br/>

으로 구분된다.

**프로그램 수행**
<br/>
CPU가 PC가 가리키는 코드영역 부분을 순차적으로 수행하고있다가
다른 함수F 가 호출되면 
- stack에 돌아올주소 저장하고
- 코드영역 점프해서 가리키고 CPU는 PC가 가리키는 해당 instruction 수행
- F가 종료되면 stack 저장된 복귀주소로 돌아온다

**인터럽트 수행**
<br/>
프로그램A가 수행중 인터럽트가 발생하면 인터럽트 처리루틴이 실행된다.
그전에 <u>돌아올 A의 코드라인 주소</u>를 저장해야한다.
- OS 데이터영역내 A의 **PCB에 프로그램A**의 복귀주소를 저장한다.
- 인터럽트처리루틴에서 함수호출은 OS 스택영역 A의 stack을 통해 이루어진다

<br/>

####컴퓨터 시스템의 작동 개요
CPU는 빠른 처리 수행을 하지만, 어떤 작업을 수행해야하는지 스스로 결정하는 능력은 없다.<br/>
메모리의 특정 주소에 존재하는 instruction을 수행할뿐이다.
- PC(Program Counter) : CPU가 수행해야할 메모리 주소를 담고있는 register. instruction 이 4byte이므로 보통 4byte씩 순차증가.

<br/>
CPU의 PC가 메모리의 운영체제를 가리키고있다면 운영체제 코드를 수행하는 중 이다.

- CPU가 커널모드에서 수행중이다 라고 한다. 그 반대면 유저모드
<br/>
CPU는 매번 명령을 수행후 인터럽트 라인을 체크에 인터럽트가 발행했는지 체크한다.

<br/>

####프로그램의 실행
프로그램이 실행되고 있다(program execution)는
- 디스크에 있는 실행파일이 메모리에 적재되었다는 뜻(프로세스)
- CPU를 할당 받아 instruction을 수행하고 있는 상태

<br/>
각각의 프로그램은 별도의 주소공간을 가진다 : 가상메모리 (virtual memory)
<br/>
p102 그림 4-3
<br/>
OS도 프로그램이므로 **OS커널**도 **코드, 데이터, 스택** 주소 공간 구성을 가진다

- 커널데이터영역 : 프로세스상태, CPU사용정보 메모리사용정보 가지고 PCB를 둔다
- 커널의스택영역 : 사용자P의 스택과 달린 프로세스마다 존재한다
  1. 커널은 공용코드라서 사용자P 마다 같은 시스템콜을 호출 했을때 임시데이터 및 복귀주소등 일관성을 유지해야한다.
  2. 커널모드에서 함수호출시 복귀주소는 커널내부이기때문에 사용자스택을 사용할수없다.
  
<br/>

인터럽트 발생시 직전프로그램의 복귀 주소는 스택이 아닌 PCB에 저장한다. 

<br/>

####인터럽트
수행중인 프로세스로 부터 CPU를 회수해 CPU가 다른 일을 수행토록하는 매커니즘

<br/>
인터럽트 처리중 인터럽트가 발생하는 경우

- 원칙적으로 해당 경우는 허용하지않는다
    - 인터럽트 처리중 커널에 정의된 데이터변경하는데 다른 인터럽트로 또 변경되면 일관성이 깨지기때문이다
    
- 예외사항으로 중요도가 큰 인터럽트가 발생한다면 현재 인터럽트 수행지점 저장하고 우선순위인터럽트 먼저 처리한다.

####시스템콜
함수 호출이지만 사용자P자신의 주소공간을 거스르는 영역의 함수를 호출하는것이다
<br/>
trap 발생하면 사용자P가 interrupt라인 세팅해서 CPU제어권 OS로 이양된다.
- 디스크 파일을 읽어와야할 경우
    1. 프로그램이 시스템 콜로 커널의 함수 호출
    2. CPU는 OS로 이양되는데, 이는 인터럽트라인을 세팅하는 명령을 통해 이뤄진다
    3. 인터럽트 서비스 루틴(ISR)이 실행된다.
    4. ISR의 instruction으로 CPU는 device controller에게 파일 읽어오라고 명령한다.
     
<br/>

**사용자P가 스스로 인터럽트라인 세팅**을 하는점만 다르고 일반적인 인터럽트와 같다.

<br/>

####프로세스의 두 가지 실행 상태
- 사용자 실행상태(user mode running)
- 커널모드 실행 상태(kernel mode running)

<br/>
p111 그림4-7
<br/>

```
시스템콜이 수행되는 동안 실제OS의 코드가 실행되는 중이지만, 커널이 실행상태(running state)에 있다고 하지않고
사용자 프로세스가 (커널모드에서)실행상태에 있다고 말한다.
사용자 프로세스가 해야할 일을 OS가 대행하는것이기때문에 그렇게 간주한다.
다만 자신의 코드 실행하는것과 구분위해서 커널모드라고 구분짓는다.
``` 