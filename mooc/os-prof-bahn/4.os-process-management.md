##프로세스 관리
####프로세스의 개념
**프로세스란 실행중인 프로그램(program in execution)**

프로세스 문맥 : 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 알기위해 필요한 정보.
- 하드웨어문맥 : CPU와 관련, PC등 각종 레지스터값
- 프로세스의 주소공간 : 메모리관련 코드 스택 데이터 로 구성된 독자적 주소공간
- 커널상의 문맥 : OS관련 PCB, 커널스택

<br/>

왜문맥이 필요한가?
<br/>
시분할 시스템에서 프로세스는 CPU을 뺏겻다 획득했다를 반복한다.
이때, CPU 재보유 후 수행 재개할때 이전 어떤 명령까지 수행했는지 알아야한다.


####프로세스의 상태
<br/>
p.116 그림

- 실행 : CPU를 보유하고 기계어명령 수행하는 상태
- 준비 : CPU만 보유하면 당장 실행가능한 상태
- 봉쇄 : CPU할당 받아도 수행 못하는 상태(입출력 작업중)
- 시작, 완료 : 일시적인 상태

**문맥교환** : 실행시킬 프로세스 변경을 위해서, 원래 수행중이 프로세스가 문맥을 저장하고, 새로운 프로세스의 문맥을 세팅하는 과정.

`CPU할당받을 프로세스 선택하고 CPU제어권 넘겨받는 과정을 CPU디스패치 라고한다`

상태변환 흐름

|흐름|모드비트|
|------|---|
| CPU가 프로세스A실행중 timer 인터럽트 발생 | 1 |
| timer interrupt service routine 실행 | 0 |
| 프로세스A 문맥 저장| 0|
| 새 프로세스B선택(A는 준비상태로) 및 B의 문맥세팅| 0|


####프로세스 제어블록
Process Control Block 은 OS가 프로세스관리하기 위한 프로세스 정보를 담는 커널내(커널메모리 Data영역)자료구조
- 프로세스 상태 
- 프로그램 카운터(program counter) : 다음에 수행할 명령 위치
- CPU 레지스터 값 : CPU연산 위해 현시점 레지스터값
- CPU 스케쥴링 정보
- 메모리 관리 정보
- 자원 사용 정보
- 입출력 상태 정보 

p120 그림

|정보 구분|정보 내용|
|------|---|
| 운영체제가 관리상 사용 용도 | 프로세스상태, 번호, 스테줄링 우선순위 |
| CPU수행관련 하드웨어 값| 프로그램카운터, 레지스터 |
| 메모리관련 | 코드, 데이터, 스택의 위치정보|
| 파일관련| 프로세스가 오픈한 파일정보|

####문맥교환
하나의 사용자프로세스에서 다른 사용자 프로세스로 CPU제어권 이양되는 과정
- 인터럽트가 발생하면 CPU제어가 OS로 넘어가 PCB에 프로세스문맥의 일부가 저장되고, 커널 코드 실행되지만, **이것은 문맥교환이라고 하지않는다**
- 프로세스의 실행모드만 변경될 뿐이고, 다른 프로세스로 변경이없다.
- 단순함 **모드 변경**이고 **문맥교환**은 더 많은 오버헤드가 뒤 따른다.
    - 실제로 문맥교환시에는 **cache memory flush** 를 해야해서 부담이 크다

####프로세스를 스케줄링하기 위한 큐
- 준비 큐(ready queue) : CPU할당 받기 위해 대기상태 있는 프로세스(**준비상태**) 집합
- 장치 큐(device queue) : 특정자원을 기다리는 프로세스(**봉쇄상태**) 들의 집합
    - 즉, 디스크, 키보드 입출력 요청한 프로세스는 disk io queue, keyboark io queue에 각각 줄 서게 된다.
    - 봉쇄상태 이지만 일은 안하는게 아니다. CPU입장에서는 일은 안하지만, device controller가 io 작업을한다.
    
    
    
p.127그림

큐는 **PCB 연결 리스트**로 구성되어있다.

####스케줄러
어떤 프로세스에게 자원을 할당할지 결정하는 **운영체제 커널 코드**
- 장기 스케줄러(long term scheduler, job scheduler)와
- 단기 스케줄러가(short term scheduler, cpu scheduler) 있다

| 장기 스케줄러 | 단기 스케줄러 |
|------|---|
| 시작상태 프로세스를 준비큐에 삽입 결정 | 준비상태 프로세스를 실행상태로 결정 |
| 프로세스를 메모리할당 할지 승인| 프로세스를 CPU할당 |
| 수십초, 수분단위로 호출 | ms 단위로 호출 |
현대 시분할OS 에서는 프로세스가 시작상태가 되면 곧바로 프로세스에 메모리를 할당해 준비큐에 넣는다.(장기스케줄러 필요없음)

- 중기 스케줄러(swapper) : degree of multiprogramming 제어 주체
    - 메모리 과다사용으로 성능저하 프로세스일부를 선정해 메모리를 통째로 disk swap area에 저장한다.(swap out)
    - 0순위 대상은 봉쇄상태 프로세스
    
p130 그림


####프로세스의 생성
- 시스템 부팅된후 최초의 프로세스는 OS가 직접생성,
- 이후 이미 존재하는 프로세스가 다른 프로세스를 복제(fork()) 생성(exec())한다.
```
main() {
   if (fork() == 0) 
      print("I am child"); 
   else
      print("I am parent");
}
```
fork()를 이용해 자식 프로세스 생성하는 예

######프로세스 수행모델
프로세스가 생성되면 부모-자식 관계가된다

- 생성된 프로세스(자식)의 자원획득 방식
    1. 부모 자원 공유 하는 모델
    2. OS로 부터 직접 자원 할당받는 모델
    
- 생성된 프로세스 수행 방식
    1. 부모 자식이 모두 공존하며 수행, 서로 경쟁관계
    2. 자식이 terminated 될때까지 부모가 wait하는 모델(ex. command line)
    
- 생성된 프로세스의 종료 방식
    1. 프로세스가 마지막 명령수행후 OS에 **자발적**으로 알려주는 방식
        - exit() 시스템콜을 통해 알린다
    2. 부모 프로세스가 강제로 종료, **비자발적**
        - abort() 시스템콜을 통해 이루어진다
        
        
######프로세스 생성과 실행
**fork(), exec() 매커니즘**
- fork() 를 통해 부모 프로세스내용을 그대로 복제 생성한다
    1. fork()시스템콜을 통해 OS 커널코드 실행
    2. ISR은 부모의 PCB 및 커널스택 등 모든 문맥 그대로 복제, 똑같은 (프로세스ID만 다른)프로세스 생성된다.
    3. 따라서 부모의 PC가 가르키는 곳부터 수행된다.
    4. fork() 결과 0 은 복제본(자식), 양수 은 원본(부모)
    
- exec() 를 통해 비로소 부모와 다른 독자적이 프로그램 수행할 수 있게 한다
    1. exec() 시스템콜을 통해 주소공간을 새로운 프로그램으로 덮어씌어진다.

    
```
wait()는 자식 프로세스가 종료될때를 부모가 기다린다(봉쇄상태로)
부모-자식 동기화에 쓰일수 있다.
자식이 종료되면 다시 CPU권한 얻을수있다.
```

####프로세스간 협력
원칙적으로 하나의 프로세스트 다른 프로세스 수행에 영향을 미칠수없다
<br/>
경우에 따라 서로 협력할때 효율성 증대 될 수 있다.
<br/>
OS는 프로세스간 협력 매커니즘(Inter-Process Communication)을 제공해서 프로세스가 다른 프로세스에 영향을 미칠 수 있게 한다.
<br/>
프로세스 사이에 공유 데이터를 사용하는지 여부에 로 IPC는 2가지로 나뉜다
- 메시지 전달(message passing) 방식 : 커널의 send(message), receive(message) 사용
    - 직접전달 방식
        - 프로세스 이름 명시 send(P, message)
    - 간접전달 방식
        - mailbox 나 port로 부터 전달받는다.
        - send(M, message), receive(M, message) 메일박스M 으로 전송, 수신 의미한다.
- 공유 메모리(shared memory) 방식
    - 서로다른 프로세스들이 주소공간의 일부를 공유
    - 논리적으로 다른 주소공간으로 구현되지만, 물리적메모리 매핑할때 동일 물리주소로 매핑되는것이다.


    
    
        
